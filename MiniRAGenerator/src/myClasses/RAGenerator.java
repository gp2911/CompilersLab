//
// Generated by JTB 1.3.2
//

package myClasses;
import visitor.*;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class RAGenerator<R> implements GJNoArguVisitor<R> {
    //
    // Auto class visitors--probably don't need to be overridden.
    //
    int indent = 0;
    boolean print;
    CodeGenerator currCoder = null;
    ProcRegDetails currProc = null;
    Stmt currStmt = null;
    Register moveVar = null;
    boolean simplexExp = false;

    Register buff0 = new Register('v', 0);
    Register buff1 = new Register('v', 1);
    Exp currExp = null;
    SimpleExp currSimplex = null;
    public HashMap<String, ProcRegDetails> procRegs = null;
    public HashMap<Integer, Temp> tmps = new HashMap<Integer, Temp>();
    public RAGenerator(HashMap<String,ProcRegDetails> hashMap){
        procRegs = hashMap;
    }
    public R visit(NodeList n) {
        R _ret=null;
        int _count=0;
        for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
        }
        return _ret;
    }

    public R visit(NodeListOptional n) {
        if ( n.present() ) {
            R _ret=null;
            int _count=0;
            for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
                e.nextElement().accept(this);
                _count++;
            }
            return _ret;
        }
        else
            return null;
    }

    public R visit(NodeOptional n) {
        if ( n.present() ){
            Label l = (Label) n.node;
            currCoder.addLabel(l.f0.toString());
            return n.node.accept(this);
        }
        else
            return null;
    }

    public R visit(NodeSequence n) {
        R _ret=null;
        int _count=0;
        for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
        }
        return _ret;
    }

    public R visit(NodeToken n) { return null; }

    //
    // User-generated visitor methods below
    //

    /**
     * f0 -> "MAIN"
     * f1 -> StmtList()
     * f2 -> "END"
     * f3 -> ( Procedure() )*
     * f4 -> <EOF>
     */
    public R visit(Goal n) {
        R _ret=null;
        currCoder = new CodeGenerator(indent);
//        System.out.println("-------------THIRD PARSE-----------------");
        n.f0.accept(this);
        currProc = procRegs.get("main");
        currCoder.addCodeLine("MAIN[0]["+currProc.stackSpaceReq+"]["+currProc.maxArgs+"]");
        indent++;
        n.f1.accept(this);
        indent--;
        currCoder.addCodeLine("END");
//        System.out.println("------------------MAIN OVER---------------------");
        currProc = null;
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
//        System.out.println("------------------THIRD PARSE COMPLETED-----------");
        System.out.println(currCoder.code);
        currCoder = null;
        return _ret;
    }

    /**
     * f0 -> ( ( Label() )? Stmt() )*
     */
    public R visit(StmtList n) {
        R _ret=null;
        CodeGenerator prevCoder = currCoder;
        currCoder = new CodeGenerator(indent);
        n.f0.accept(this);
        prevCoder.addCode(currCoder.code);
        currCoder = prevCoder;
        return _ret;
    }

    /**
     * f0 -> Label()
     * f1 -> "["
     * f2 -> IntegerLiteral()
     * f3 -> "]"
     * f4 -> StmtExp()
     */
    public R visit(Procedure n) {
        R _ret=null;
//        System.out.println("-------------------"+n.f0.f0.toString()+"------------------------");
        ProcRegDetails prevProc = currProc;
        currProc = procRegs.get(n.f0.f0.toString());
//        System.out.println(currProc.tempSet);

        CodeGenerator prevCoder = currCoder;
        currCoder = new CodeGenerator(indent);
        n.f0.accept(this);
        currCoder.addCode(n.f0.f0.toString());
        currCoder.addCodeLine("[" + n.f2.f0.toString() + "][" + currProc.stackSpaceReq + "][" + currProc.maxArgs + "]");
        int i = 0;
        if(currProc.argNum > 4)
            i = currProc.argNum - 4;
        while(i < currProc.stackSpaceReq && i < 8 ){
            currCoder.addCodeLine("ASTORE SPILLEDARG "+i+ " s"+i);
            i++;
        }
        i = 0;
        while(i < currProc.argNum && i < 4){
            Temp t = currProc.localTemps.get(i);
//            System.out.println(currProc.tempLiveMapping.toString()+" : "+t+" : "+i);
            if(t != null){
                Register r = currProc.tempLiveMapping.get(t).peekFirst().reg;
                if(r.type != 'x')
                    currCoder.addCodeLine("MOVE "+ r.toString()+" a"+i);
                else{
                    currCoder.addCodeLine("ALOAD "+buff0.toString()+" SPILLEDARG "+Integer.toString(r.regNo-18));
                    currCoder.addCodeLine("MOVE "+buff0.toString()+" a"+i);
                }
            }
            i++;
        }
        if(i < currProc.argNum)
            while (i < currProc.argNum){
                currCoder.addCodeLine("ALOAD "+currProc.localTemps.get(i).liveRange.getFirst().reg.toString()+" SPILLEDARG "+Integer.toString(i-4));
//                currCoder.addCodeLine("MOVE "+currProc.localTemps.get(i).liveRange.getFirst().reg.toString()+" "+buff0.toString());
                i++;
            }

        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);

        i=0;
        if(currProc.argNum > 4)
            i = currProc.argNum - 4;
        while(i < currProc.stackSpaceReq && i < 8){
            currCoder.addCodeLine("ALOAD s"+i+" SPILLEDARG "+i);
            i++;
        }
        currCoder.addCodeLine("END");
        prevCoder.addCode(currCoder.code);
        currCoder = prevCoder;
        currProc = prevProc;
        return _ret;
    }

    /**
     * f0 -> NoOpStmt()
     *       | ErrorStmt()
     *       | CJumpStmt()
     *       | JumpStmt()
     *       | HStoreStmt()
     *       | HLoadStmt()
     *       | MoveStmt()
     *       | PrintStmt()
     */
    public R visit(Stmt n) {
        R _ret=null;
        Stmt prevStmt = currStmt;
        currStmt = n;
        CodeGenerator prevCoder = currCoder;
        currCoder = new CodeGenerator(indent);
        n.f0.accept(this);
        prevCoder.addCode(currCoder.code);
        currCoder = prevCoder;
        currStmt = prevStmt;
        return _ret;
    }

    /**
     * f0 -> "NOOP"
     */
    public R visit(NoOpStmt n) {
        R _ret=null;
        n.f0.accept(this);
        currCoder.addCodeLine("NOOP");
        return _ret;
    }

    /**
     * f0 -> "ERROR"
     */
    public R visit(ErrorStmt n) {
        R _ret=null;
        n.f0.accept(this);
        currCoder.addCodeLine("ERROR");
        return _ret;
    }

    /**
     * f0 -> "CJUMP"
     * f1 -> Temp()
     * f2 -> Label()
     */
    public R visit(CJumpStmt n) {
        R _ret=null;
        n.f0.accept(this);
//        n.f1.accept(this);
        n.f2.accept(this);
        Temp t = null;
        int tmpnum = Integer.parseInt(n.f1.f1.f0.toString());
        if(tmpnum >= currProc.argNum)
            t = tmps.get(tmpnum);
        else
            t = currProc.localTemps.get(tmpnum);
        LinkedList<LiveRange> liveRanges = currProc.tempLiveMapping.get(t);
        LiveRange l = liveRanges.peekFirst();
        Register r = null;
//        System.out.println(l.tmp.toString());
//        System.out.println(l.start.stmtIndex+" : "+l.end.stmtIndex+" >>>> "+currStmt.stmtIndex);
        if(currStmt.stmtIndex >= l.start.stmtIndex && currStmt.stmtIndex <= l.end.stmtIndex)
            r = l.reg;
        else if(currStmt.stmtIndex > l.end.stmtIndex){
            liveRanges.removeFirst();
            l = liveRanges.peekFirst();
            if(l != null)
                r = l.reg;
            else
                return null;
        }
        else{
            liveRanges.getFirst().start = currStmt;
            r = liveRanges.getFirst().reg;
        }
        String spillHandler = r.regCode(buff0);
        if(spillHandler == null)
            currCoder.addCodeLine("CJUMP "+r.toString()+" "+n.f2.f0.toString());
        else{
            currCoder.addCodeLine(spillHandler);
            currCoder.addCodeLine("CJUMP "+buff0.toString()+" "+n.f2.f0.toString());
        }
//        currCoder.addCodeLine("CJUMP "+currPr);
        return _ret;
    }

    /**
     * f0 -> "JUMP"
     * f1 -> Label()
     */
    public R visit(JumpStmt n) {
        R _ret=null;
        n.f0.accept(this);
        n.f1.accept(this);
        currCoder.addCodeLine("JUMP "+n.f1.f0.toString());
        return _ret;
    }

    /**
     * f0 -> "HSTORE"
     * f1 -> Temp()
     * f2 -> IntegerLiteral()
     * f3 -> Temp()
     */
    public R visit(HStoreStmt n) {
        R _ret=null;
        n.f0.accept(this);
//        n.f1.accept(this);
        n.f2.accept(this);
//        n.f3.accept(this);
        int tmpnum1 = Integer.parseInt(n.f1.f1.f0.toString());
        int tmpnum2 = Integer.parseInt(n.f3.f1.f0.toString());
        Temp t1, t2;
        if(tmpnum1 >= currProc.argNum)
            t1 = tmps.get(tmpnum1);
        else
            t1 = currProc.localTemps.get(tmpnum1);
        if(tmpnum2 >= currProc.argNum)
            t2 = tmps.get(tmpnum2);
        else
            t2 = currProc.localTemps.get(tmpnum2);
//        System.out.println(t1);
        LinkedList<LiveRange> liveRanges = currProc.tempLiveMapping.get(t1);
        LiveRange l = liveRanges.peekFirst();
        Register r1 = null;

        if(currStmt.stmtIndex >= l.start.stmtIndex && currStmt.stmtIndex <= l.end.stmtIndex)
            r1 = l.reg;
        else if(currStmt.stmtIndex > l.end.stmtIndex){
            liveRanges.removeFirst();
            l = liveRanges.peekFirst();
            if(l != null)
                r1 = l.reg;
            else
                return null;
        }
        else{
            liveRanges.getFirst().start = currStmt;
            r1 = liveRanges.getFirst().reg;
        }

        liveRanges = currProc.tempLiveMapping.get(t2);
        l = liveRanges.peekFirst();
        Register r2 = null;
        if(currStmt.stmtIndex >= l.start.stmtIndex && currStmt.stmtIndex <= l.end.stmtIndex)
            r2 = l.reg;
        else if(currStmt.stmtIndex > l.end.stmtIndex){
            liveRanges.removeFirst();
            l = liveRanges.peekFirst();
            if(l != null)
                r2 = l.reg;
            else
                return null;
        }
        else{
            liveRanges.getFirst().start = currStmt;
            r2 = liveRanges.getFirst().reg;
        }
        String spillHandler1 = r1.regCode(buff0);
        String spillHandler2;
        if(spillHandler1 != null)
            spillHandler2 = r2.regCode(buff1);
        else
            spillHandler2 = r2.regCode(buff0);

        if(spillHandler1 == null && spillHandler2 == null){
            currCoder.addCodeLine("HSTORE "+r1.toString()+" "+n.f2.f0.toString()+" "+r2.toString());
        }
        if(spillHandler1 == null && spillHandler2 != null){
            currCoder.addCodeLine(spillHandler2);
            currCoder.addCodeLine("HSTORE "+r1.toString()+" "+n.f2.f0.toString()+" "+buff0.toString());
        }
        if(spillHandler1 != null && spillHandler2 == null){
            currCoder.addCodeLine(spillHandler1);
            currCoder.addCodeLine("HSTORE "+r1.toString()+" "+n.f2.f0.toString()+" "+buff0.toString());
        }
        if(spillHandler1 != null && spillHandler2 != null){
            currCoder.addCodeLine(spillHandler1);
            currCoder.addCodeLine(spillHandler2);
            currCoder.addCodeLine("HSTORE "+buff0.toString()+" "+n.f2.f0.toString()+" "+buff1.toString());
        }

        return _ret;
    }

    /**
     * f0 -> "HLOAD"
     * f1 -> Temp()
     * f2 -> Temp()
     * f3 -> IntegerLiteral()
     */
    public R visit(HLoadStmt n) {
        R _ret=null;
        n.f0.accept(this);
//        n.f1.accept(this);
//        n.f2.accept(this);
        n.f3.accept(this);

        int tmpnum1 = Integer.parseInt(n.f1.f1.f0.toString());
        int tmpnum2 = Integer.parseInt(n.f2.f1.f0.toString());
        Temp t1, t2;
        if(tmpnum1 >= currProc.argNum)
            t1 = tmps.get(tmpnum1);
        else
            t1 = currProc.localTemps.get(tmpnum1);
        if(tmpnum2 >= currProc.argNum)
            t2 = tmps.get(tmpnum2);
        else
            t2 = currProc.localTemps.get(tmpnum2);

        LinkedList<LiveRange> liveRanges = currProc.tempLiveMapping.get(t1);
        LiveRange l = liveRanges.peekFirst();
        Register r1 = null;
        if(currStmt.stmtIndex >= l.start.stmtIndex && currStmt.stmtIndex <= l.end.stmtIndex)
            r1 = l.reg;
        else if(currStmt.stmtIndex > l.end.stmtIndex){
            liveRanges.removeFirst();
            l = liveRanges.peekFirst();
            r1 = l.reg;
        }
        else{
            liveRanges.getFirst().start = currStmt;
            r1 = liveRanges.getFirst().reg;
        }
//        System.out.println();
        liveRanges = currProc.tempLiveMapping.get(t2);
        l = liveRanges.peekFirst();
        Register r2 = null;
        if(currStmt.stmtIndex >= l.start.stmtIndex && currStmt.stmtIndex <= l.end.stmtIndex)
            r2 = l.reg;
        else{
            liveRanges.removeFirst();
            l = liveRanges.peekFirst();
            r2 = l.reg;
        }

        String spillHandler1, spillHandler2;
        spillHandler1 = r1.regCode(buff0);
        if(spillHandler1 == null)
            spillHandler2 = r2.regCode(buff0);
        else
            spillHandler2 = r2.regCode(buff1);

        if(spillHandler1 == null && spillHandler2 == null){
            currCoder.addCodeLine("HLOAD "+r1.toString()+" "+r2.toString()+" "+n.f3.f0.toString());
        }
        if(spillHandler1 == null && spillHandler2 != null){
            currCoder.addCodeLine(spillHandler2);
            currCoder.addCodeLine("HLOAD "+r1.toString()+" "+buff0.toString()+" "+n.f3.f0.toString());
        }
        if(spillHandler1 != null && spillHandler2 == null){
            currCoder.addCodeLine(spillHandler1);
            currCoder.addCodeLine("HLOAD "+buff0.toString()+" "+r2.toString()+" "+n.f3.f0.toString());
        }
        if(spillHandler1 != null && spillHandler2 != null){
            currCoder.addCodeLine(spillHandler1);
            currCoder.addCodeLine(spillHandler2);
            currCoder.addCodeLine("HLOAD "+buff0.toString()+" " +buff1.toString()+" "+n.f3.f0.toString());
        }
        return _ret;
    }

    /**
     * f0 -> "MOVE"
     * f1 -> Temp()
     * f2 -> Exp()
     */
    public R visit(MoveStmt n) {
        R _ret=null;
        n.f0.accept(this);

        Temp t1 = null;
        int tmpnum = Integer.parseInt(n.f1.f1.f0.toString());
        if(tmpnum < currProc.argNum)
            t1 = currProc.localTemps.get(tmpnum);
        else
            t1 = tmps.get(tmpnum);
//        System.out.println(t1);
//        System.out.println(t1.liveRange);
//        if(!t1.liveRange.isEmpty())
//            System.out.println(t1.liveRange.getLast().start+" : "+t1.liveRange.getLast().end);
        LinkedList<LiveRange> liveRanges = currProc.tempLiveMapping.get(t1);
//        System.out.println(liveRanges);
        if(liveRanges == null)
            return null;
        LiveRange l = liveRanges.peekFirst();
//        System.out.println(l);
        Register r1 = null;
        if(l == null)
            return null;
//        System.out.println(l.tmp.toString()+" : "+l.reg.toString());
//        System.out.println(l.start.stmtIndex+"  :  "+l.end.stmtIndex+">>>>>>"+currStmt.stmtIndex);
        if(currStmt.stmtIndex >= l.start.stmtIndex && currStmt.stmtIndex <= l.end.stmtIndex)
            r1 = l.reg;
        else if(currStmt.stmtIndex > l.end.stmtIndex){
            liveRanges.removeFirst();
            l = liveRanges.peekFirst();
            if(l != null)
                r1 = l.reg;
            else
                return null;
        }
        else{
            liveRanges.getFirst().start = currStmt;
            r1 = liveRanges.getFirst().reg;
        }


        moveVar = null;
        if(r1.type != 'x'){
           moveVar = r1;
        }
        else{  // lhs has been spilled
            if(n.f2.f0.which != 0){   //if it is not a call
                moveVar = buff0;
            }
            else{
                moveVar = buff1;
            }

        }

//        n.f2.accept(this);
        String exprCode = (String) n.f2.accept(this);
        String exprSpillCode = n.f2.spillCode;

        if(r1.type != 'x'){
            if(n.f2.f0.which != 0){ //not a call
                if(exprSpillCode != null)
                    currCoder.addCodeLine(exprSpillCode);
                currCoder.addCode(exprCode);
            }
            else{ //call
                currCoder.addCode(exprCode);
            }
        }
        else{  // lhs has been spilled
            if(n.f2.f0.which != 0){   //if it is not a call
                if(exprSpillCode != null )
                    currCoder.addCode(exprSpillCode);
                currCoder.addCodeLine("ASTORE SPILLEDARG "+Integer.toString(r1.regNo -18)+" "+buff0.toString());
            }
            else{ //call
                currCoder.addCode(exprCode);
                currCoder.addCodeLine("ASTORE SPILLEDARG "+Integer.toString(r1.regNo -18)+" "+buff1.toString());
            }

        }
        moveVar = null;
        return _ret;
    }

    /**
     * f0 -> "PRINT"
     * f1 -> SimpleExp()
     */
    public R visit(PrintStmt n) {
        R _ret=null;
        n.f0.accept(this);
        String simplexCode = (String)n.f1.accept(this);
        String simplexSpillCode = n.f1.spillCode;
        if(simplexSpillCode != null)
            currCoder.addCode(simplexSpillCode);
        currCoder.addCodeLine("PRINT "+simplexCode);
        return _ret;
    }

    /**
     * f0 -> Call()
     *       | HAllocate()
     *       | BinOp()
     *       | SimpleExp()
     */
    public R visit(Exp n) {
        R _ret=null;
        Exp prevExp = currExp;
        currExp = n;
        if(n.f0.which == 3)
            simplexExp = true;
        String ret = (String) n.f0.accept(this);
        simplexExp = false;
        currExp = prevExp;
        return (R) ret;
    }

    /**
     * f0 -> "BEGIN"
     * f1 -> StmtList()
     * f2 -> "RETURN"
     * f3 -> SimpleExp()
     * f4 -> "END"
     */
    public R visit(StmtExp n) {
        R _ret=null;
        n.f0.accept(this);
//        currCoder.addCodeLine("BEGIN");
        indent++;
        currCoder.indent++;
        CodeGenerator prevCoder = currCoder;
        currCoder = new CodeGenerator(indent);
        n.f1.accept(this);
        prevCoder.addCodeLine(currCoder.code);
        currCoder = prevCoder;
        n.f2.accept(this);

//        prevCoder = currCoder;
//        currCoder = new CodeGenerator(indent);
//        System.out.println(currProc.stmtList.getLast());
        currStmt = currProc.stmtList.getLast();
//        System.out.println(currStmt);
        String simplexCode = (String) n.f3.accept(this);
        String simplexSpillCode = n.f3.spillCode;
//        prevCoder.addCodeLine(currCoder.code);
        if(simplexSpillCode != null){
            currCoder.addCodeLine(simplexSpillCode);
        }
        currCoder.addCodeLine("MOVE v0 "+simplexCode);
//        currCoder = prevCoder;
        indent--;
        currCoder.indent--;
        n.f4.accept(this);
//        currCoder.addCodeLine("END");
        return _ret;
    }

    /**
     * f0 -> "CALL"
     * f1 -> SimpleExp()
     * f2 -> "("
     * f3 -> ( Temp() )*
     * f4 -> ")"
     */
    public R visit(Call n) {
        R _ret=null;
        String callString = "";
        n.f0.accept(this);
//        System.out.println(n.f3.size());
        String simplexCode = (String) n.f1.accept(this);
        String simplexSpillCode = n.f1.spillCode;
        n.f2.accept(this);
//        n.f3.accept(this);
        Enumeration tmpEnum = n.f3.elements();
        ArrayList<Register> regs = new ArrayList<Register>();
        while(tmpEnum.hasMoreElements()){
            Temp tmp = (Temp) tmpEnum.nextElement();
            int tmpnum = Integer.parseInt(tmp.f1.f0.toString());
            Temp t =null;
            if(tmpnum < currProc.argNum)
                t = currProc.localTemps.get(tmpnum);
            else
                t = tmps.get(tmpnum);
            LinkedList<LiveRange> liveRanges = currProc.tempLiveMapping.get(t);
            LiveRange l = liveRanges.peekFirst();
            if(currStmt.stmtIndex >= l.start.stmtIndex && currStmt.stmtIndex <= l.end.stmtIndex)
                regs.add(l.reg);
            else if(currStmt.stmtIndex > l.end.stmtIndex){
                liveRanges.removeFirst();
                l = liveRanges.peekFirst();
                if(l != null)
                    regs.add(l.reg);
                else
                    return null;
            }
            else{
                liveRanges.getFirst().start = currStmt;
                regs.add(liveRanges.getFirst().reg);
            }

        }
        Iterator<Register> regIter = regs.iterator();
        int i = 0;
        while(regIter.hasNext() && i < 4){
            Register r = regIter.next();
            if(r.type != 'x'){ //if arg passed is in register
                callString = callString+"MOVE a"+i+" "+r.toString()+"\n";
            }
            else{ //if arg is in stack
                callString = callString+"ALOAD "+buff0.toString()+" SPILLEDARG "+Integer.toString(r.regNo -18)+"\n";
                callString = callString+"MOVE a"+i+" "+buff0.toString()+"\n";
            }
            i++;
        }
        currProc.stackIndex = 0;
        if(regIter.hasNext()){
            while (regIter.hasNext()){
                Register r = regIter.next();
                if(r.type != 'x')
                    callString = callString+"PASSARG "+Integer.toString(currProc.stackIndex + 1)+" "+ r.toString()+"\n";
                else{
                    callString = callString+"ALOAD "+buff0.toString()+" SPILLEDARG "+Integer.toString(r.regNo -18)+"\n";
                    callString = callString+"PASSARG "+Integer.toString(currProc.stackIndex + 1)+" "+ buff0.toString()+"\n";
                }
                currProc.stackIndex++;
            }
        }
        callString = callString+"CALL " + simplexCode+"\n";
        callString = callString+"MOVE "+moveVar.toString()+" v0\n";
        n.f4.accept(this);
        return (R) callString;
    }

    /**
     * f0 -> "HALLOCATE"
     * f1 -> SimpleExp()
     */
    public R visit(HAllocate n) {
        R _ret=null;
        n.f0.accept(this);
        String simplexCode = (String) n.f1.accept(this);
        String simplexSpillCode = n.f1.spillCode;
        String ret = "";
        if(simplexSpillCode != null)
            ret = ret + simplexSpillCode+"\n";
        ret = ret + "MOVE "+moveVar+" HALLOCATE "+simplexCode+"\n";
        return (R) ret;
    }

    /**
     * f0 -> Operator()
     * f1 -> Temp()
     * f2 -> SimpleExp()
     */
    public R visit(BinOp n) {
        R _ret=null;
        n.f0.accept(this);
        String spillStr = "";
        String ret = "";
//        n.f1.accept(this);
        String opString = null;
        switch (n.f0.f0.which){
            case 0:
                opString = "LT ";
                break;
            case 1:
                opString = "PLUS ";
                break;
            case 2:
                opString = "MINUS ";
                break;
            case 3:
                opString = "TIMES ";
                break;
        }

        Temp t1 = null;
        int tmpnum = Integer.parseInt(n.f1.f1.f0.toString());
        if(tmpnum > currProc.argNum)
            t1 = tmps.get(tmpnum);
        else
            t1 = currProc.localTemps.get(tmpnum);

        LinkedList<LiveRange> liveRanges = currProc.tempLiveMapping.get(t1);
        LiveRange l = liveRanges.peekFirst();
        Register r1 = null;
//        System.out.println(currStmt);
//        System.out.println(l);
        if(currStmt.stmtIndex >= l.start.stmtIndex && currStmt.stmtIndex <= l.end.stmtIndex)
            r1 = l.reg;
        else if(currStmt.stmtIndex > l.end.stmtIndex){
            liveRanges.removeFirst();
            l = liveRanges.peekFirst();
            if(l != null)
                r1 = l.reg;
            else
                return null;
        }
        else{
            liveRanges.getFirst().start = currStmt;
            r1 = liveRanges.getFirst().reg;
        }
        if(r1.type != 'x')
            ret = ret+ "MOVE "+moveVar+" "+opString+" "+r1.toString()+"\n";
        else{
            //TODO the else part, if i need to load the tmp from the stack
            //Load the code to bring in from the stack in spillStr
            spillStr = spillStr + "ALOAD "+buff0.toString()+" SPILLEDARG "+Integer.toString(r1.regNo -18)+"\n";
            ret = ret + "MOVE "+moveVar+" "+opString +" "+ buff0.toString()+"\n";
        }

        String simplexCode = (String) n.f2.accept(this);
        String simplexSpillCode = n.f2.spillCode;
        if(simplexSpillCode!=null)
            spillStr = spillStr + simplexSpillCode;
        ret = ret + simplexCode + "\n";

        currExp.spillCode = spillStr;

        return (R) ret;
    }

    /**
     * f0 -> "LT"
     *       | "PLUS"
     *       | "MINUS"
     *       | "TIMES"
     */
    public R visit(Operator n) {
        R _ret=null;
        n.f0.accept(this);
        return _ret;
    }

    /**
     * f0 -> Temp()
     *       | IntegerLiteral()
     *       | Label()
     */
    public R visit(SimpleExp n) {
        R _ret=null;
        //TODO
        SimpleExp prevSimplex = currSimplex;
        currSimplex = n;
        String ret = (String) n.f0.accept(this);
        if(simplexExp == true){
            ret  = "MOVE "+moveVar+" "+ret+"\n";
        }
        currSimplex = prevSimplex;
        return (R) ret;
    }

    /**
     * f0 -> "TEMP"
     * f1 -> IntegerLiteral()
     */
    public R visit(Temp n) {
        R _ret=null;
        n.f0.accept(this);
//        n.f1.accept(this);
        int tmpNum = Integer.parseInt(n.f1.f0.toString());
        Temp t1 = null;

        if(tmpNum < currProc.argNum){
            t1 = currProc.localTemps.get(tmpNum);
        }
        else{
            t1 = tmps.get(tmpNum);
        }

        LinkedList<LiveRange> liveRanges = currProc.tempLiveMapping.get(t1);
//        System.out.println(currProc.tempLiveMapping.toString()+"  :  "+t1);
//        System.out.println(liveRanges);
        LiveRange l = liveRanges.peekFirst();
        Register r1 = null;
//        System.out.println(currStmt);
//        System.out.println(l.toString2());
        if(currStmt.stmtIndex >= l.start.stmtIndex && currStmt.stmtIndex <= l.end.stmtIndex)
            r1 = l.reg;
        else if(currStmt.stmtIndex > l.end.stmtIndex){
            liveRanges.removeFirst();
            l = liveRanges.peekFirst();
            if(l != null)
                r1 = l.reg;
            else
                return null;
        }
        else{
            liveRanges.getFirst().start = currStmt;
            r1 = liveRanges.getFirst().reg;
        }
        if(r1.type == 'x' && currSimplex != null){
            currSimplex.spillCode = "ALOAD "+buff0.toString()+ " SPILLEDARG "+Integer.toString(r1.regNo-18);
            return (R) buff0.toString();
        }
        else
            currSimplex.spillCode = null;
//        currCoder.addCode(r1.toString());
        return (R) r1.toString();
    }

    /**
     * f0 -> <INTEGER_LITERAL>
     */
    public R visit(IntegerLiteral n) {
        R _ret=null;
        n.f0.accept(this);
//        currCoder.addCode(n.f0.toString());
        return (R) n.f0.toString();
    }

    /**
     * f0 -> <IDENTIFIER>
     */
    public R visit(Label n) {
        R _ret=null;
        n.f0.accept(this);
//        currCoder.addCode(n.f0.toString());
        return (R) n.f0.toString();
    }

}
