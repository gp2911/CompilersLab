package myClasses;

/**
 * Created with IntelliJ IDEA.
 * User: GP
 * Date: 25/09/13
 * Time: 5:27 PM
 * To change this template use File | Settings | File Templates.
 */


//
// Generated by JTB 1.3.2
//

import syntaxtree.*;
import visitor.GJNoArguVisitor;

import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */

public class CodePrinter<R> implements GJNoArguVisitor<R> {
    //
    // Auto class visitors--probably don't need to be overridden.
    //

    Hashtable<String, ClassDetails> symbolTable; //<<<<<<<<<<<
    ArrayList<Integer> heapStore = new ArrayList<Integer>(); //<<<<<<<<<<<<<
    ArrayList<Integer> memAlloc = new ArrayList<Integer>();
    Hashtable<String, ClassDetails> objRecords = new Hashtable<String, ClassDetails>(); //<<<<<<<<<<<
    ArrayList<Integer> currParams;
    LinkedHashMap<String,VarDetails> currVarTable;
    String currObject= "";
    String currMethodCode="";
    CodeGenerator currCoder = null;
    CodeGenerator prevCoder = null;
    int paramIndex;
    boolean inIf = false;
    Stmt currStmt = null;
    String message = "";

    CodeGenerator mainCoder = new CodeGenerator();
    CodeGenerator secondaryCoder = new CodeGenerator();
    ArrayList<FuncCode> currFuncCodes;
    Hashtable<String, Integer> tempVarMapping = new Hashtable<String, Integer>();
    Hashtable<String, Integer> currLocalTemps = new Hashtable<String, Integer>();

    int tempIndex = 25;
    int paramCount = 0;
    int labelIndex = 1;
    int indent =0;

    boolean inExpr = false;
    boolean inFunc = false;
    boolean isAssign = false;
    boolean inClass  = false;

    public void setSymbolTable( Hashtable<String, ClassDetails> hashtable){
        symbolTable = hashtable;
    }

    public Hashtable<String, ClassDetails> getSymbolTable() {
        return symbolTable;
    }

    public CodeGenerator getMainCoder(){
        return mainCoder;
    }

    public void setMainCoder( CodeGenerator coder){
        mainCoder = coder;
    }

    public CodeGenerator getSecondaryCoder(){
        return secondaryCoder;
    }

    public void setSecondaryCoder( CodeGenerator coder){
        secondaryCoder = coder;
    }

    public  void setTempVarMapping( Hashtable<String, Integer> t){
        tempVarMapping = t;
    }
    public  Hashtable<String, Integer> getTempVarMapping(){
        return tempVarMapping;
    }

    ClassDetails currClass = null;
    FuncDetails currFunc = null;



    public R visit(NodeList n) {
        R _ret=null;
        int _count=0;
        for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
        }
        return _ret;
    }

    public R visit(NodeListOptional n) {
        if ( n.present() ) {
            R _ret=null;
            int _count=0;
            for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
                e.nextElement().accept(this);
                _count++;
            }
            return _ret;
        }
        else
            return null;
    }

    public R visit(NodeOptional n) {
        if ( n.present() )
            return n.node.accept(this);
        else
            return null;
    }

    public R visit(NodeSequence n) {
        R _ret=null;
        int _count=0;
        for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
        }
        return _ret;
    }

    public R visit(NodeToken n) { return null; }

    //
    // User-generated visitor methods below
    //

    /**
     * f0 -> MainClass()
     * f1 -> ( TypeDeclaration() )*
     * f2 -> <EOF>
     */
    public R visit(Goal n) {
        R _ret=null;
//        System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Third Pass<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
        CodeGenerator prevCoder = currCoder;
        currCoder = mainCoder;
        n.f0.accept(this);
        n.f1.accept(this);
        //System.out.println(mainCoder.code);
        n.f2.accept(this);
//        System.out.println("{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{");
        System.out.println(mainCoder.code);
//        System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
        currCoder = prevCoder;

        // Loop to remove some stupid classes I am getting from symbolTable

        Iterator<String> i = symbolTable.keySet().iterator();
//        System.out.println(symbolTable);
        Hashtable<String, ClassDetails> newSymbTab  = new Hashtable<String, ClassDetails>();
//        System.out.println("$$----TypeDeclns----$$");
        while(i.hasNext()){
            String s = i.next();
            ClassDetails classDetails = symbolTable.get(s);
            if(!s.contains("."))
                newSymbTab.put(s,classDetails );
        }
        symbolTable = newSymbTab;

        //Print out all my Class funcs

//        System.out.println("$$----Functions----$$");
        i = symbolTable.keySet().iterator();
        while (i.hasNext()){
            String myClass = i.next() ;
            if(symbolTable.get(myClass) != null && symbolTable.get(myClass).classFuncCodes != null){
//                System.out.println("∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂∂");
//                System.out.println("CLASS "+symbolTable.get(myClass).name);
//                System.out.println(symbolTable.get(myClass).classFuncCodes);
                Iterator<FuncCode> func = symbolTable.get(myClass).classFuncCodes.iterator();
                while(func.hasNext()){
                    FuncCode myFunc = func.next();
//                    System.out.println("-------------");
                    System.out.println(myFunc.funcCode);
                }
            }
        }

        //Loop to add funcCodes for non-overridden funcs of derived classes.
        //TODO: SHIFT THIS TO FIRST PASS

        Iterator<ClassDetails> myClassIt = symbolTable.values().iterator();

        while (myClassIt.hasNext()){

            ClassDetails myClass = myClassIt.next();
//            System.out.println(" Analyzing Class "+ myClass.name);
            if(myClass.isChild){
//                System.out.println("Child class "+myClass.name);
                ClassDetails parent = myClass.parentClass;
                Iterator<String> parFunIt = parent.classFuncs.keySet().iterator();
//                System.out.println(parent.isDefined);
                while(parFunIt.hasNext()){
//                    System.out.println("In here...");
                    String s = parFunIt.next();
                    FuncDetails myfunc = parent.classFuncs.get(s);
                    if(!myfunc.isOverridden){
                        CodeGenerator myCoder = new CodeGenerator();
//                        myCoder.addCodeLine(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>in PostGoal processing<<<<<<<<<<<<<<<<<<<<<");
                        myCoder.addCodeLine(myClass.name+"_"+myfunc.name+"["+Integer.toString(myfunc.argumentTypes.size()+1)+"]");
                        myCoder.addCodeLine("BEGIN");
                        myCoder.indent++;
                        indent++;
                        int numOfParams = myfunc.argumentTypes.size()+1;
                        String paramList = "TEMP 0";
                        for(int k=1; k < numOfParams; k++){
                            paramList = paramList + " TEMP "+ k;
                        }
                        myCoder.addCodeLine("MOVE TEMP "+tempIndex+" CALL "+parent.name+"_"+myfunc.name+"("+paramList+")");
                        myCoder.addCodeLine("RETURN TEMP "+tempIndex);
                        indent--;
                        myCoder.indent--;
                        myCoder.addCodeLine("END");
                        tempIndex++;
                        FuncCode myFuncCode = new FuncCode();
                        myFuncCode.funcName = myClass.name+"_"+myfunc.name;
                        myFuncCode.funcCode = myCoder.code;
                        System.out.println(myFuncCode.funcCode);
                    }
                }
            }
        }
        return _ret;
    }

    /**
     * f0 -> "class"
     * f1 -> Identifier()
     * f2 -> "{"
     * f3 -> "public"
     * f4 -> "static"
     * f5 -> "void"
     * f6 -> "main"
     * f7 -> "("
     * f8 -> "String"
     * f9 -> "["
     * f10 -> "]"
     * f11 -> Identifier()
     * f12 -> ")"
     * f13 -> "{"
     * f14 -> PrintStatement()
     * f15 -> "}"
     * f16 -> "}"
     */

    //TODO: RETAIN THIS FOR 3RD PASS. DO NOT SHIFT.

    public R visit(MainClass n) {
        R _ret=null;
        ClassDetails prevClass = currClass;
        prevCoder = currCoder;

        currClass = symbolTable.get(n.f1.f0.toString());

        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
        n.f5.accept(this);
        n.f6.accept(this);
        //After seeing "main"
        mainCoder.addCodeLine("MAIN");
//        System.out.println("Code: "+code);
        indent++;
        mainCoder.indent++;

        n.f7.accept(this);
        n.f8.accept(this);
        n.f9.accept(this);
        n.f10.accept(this);
        n.f11.accept(this);
        n.f12.accept(this);
        n.f13.accept(this);
        Stmt print = (Stmt)n.f14.accept(this);
//        System.out.println("=======================");
//        System.out.println(mainCoder.indent);
        mainCoder.addCodeLine(print.code);
//        System.out.println("Print code: "+ print.code);
//        if(print!=null)
//            mainCoder.addCode(print.code, mainCoder.indent);
        n.f15.accept(this);
        //End of MAIN
        mainCoder.indent--;
        mainCoder.addCodeLine("END");
        //System.out.println("®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®");
        //System.out.println("Code: "+mainCoder.code);
        indent--;
//        System.out.println(mainCoder.code);
//        mainCoder.cleanCode();
        n.f16.accept(this);
        currCoder = prevCoder;
        currClass = prevClass;

        return _ret;
    }

    /**
     * f0 -> ClassDeclaration()
     *       | ClassExtendsDeclaration()
     */
    public R visit(TypeDeclaration n) {
        R _ret=null;
        n.f0.accept(this);
        return _ret;
    }

    /**
     * f0 -> "class"
     * f1 -> Identifier()
     * f2 -> "{"
     * f3 -> ( VarDeclaration() )*
     * f4 -> ( MethodDeclaration() )*
     * f5 -> "}"
     */

    //TODO: SHIFT THIS TO 1ST PASS
    public R visit(ClassDeclaration n) {
        R _ret=null;
        currVarTable = new LinkedHashMap<String, VarDetails>();
        ClassDetails prevClass = currClass;
        prevCoder  =currCoder;

        prevClass = currClass;
        currClass = symbolTable.get(n.f1.f0.toString());

        currFuncCodes = currClass.classFuncCodes;
        if(currFuncCodes == null)      {
            currClass.classFuncCodes = new ArrayList<FuncCode>();
            currFuncCodes = currClass.classFuncCodes;
        }


        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        inClass  =true;
        n.f3.accept(this);
        inClass = false;
        n.f4.accept(this);
        n.f5.accept(this);

//        System.out.println("############################");
//        System.out.println(currVarTable);
//        System.out.println();
//        System.out.println();


        currClass.initHash = currVarTable;
        CodeGenerator subCoder = new CodeGenerator();
//        subCoder.addCodeLine(">>>>>>>>>>>>>>>>>>>>>>>>>>>>in Class Decln>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
//        subCoder.addCodeLine("############################");
//        subCoder.addCodeLine(currVarTable.toString());
//        subCoder.addCodeLine(currClass.classVars.toString());
        subCoder.addCodeLine("new_"+currClass.name + " [ 0 ]");
        subCoder.addCodeLine("BEGIN");
        subCoder.indent++;
        indent++;
        int vTableSize = 4 * currClass.classFuncs.size();
        int objSize = 4 * (currVarTable.size() + 1);
        currClass.initHash = currVarTable;
        // allocate vtable
        subCoder.addCodeLine("MOVE TEMP "+ tempIndex +" HALLOCATE "+ vTableSize);
        tempIndex++;
        //allocate object
        subCoder.addCodeLine("MOVE TEMP "+ tempIndex +" HALLOCATE "+ objSize );
        //add to tempVarMap
        tempVarMapping.put(currClass.name + "_vTable", tempIndex-1);
        tempVarMapping.put(currClass.name + "_obj_"+currClass.objCount, tempIndex);
        currClass.objCount++;
        //build vtable
        Iterator<String> iterator = currClass.classFuncs.keySet().iterator();
        int i=0;
        while (iterator.hasNext()){
            String tmp = iterator.next();
            subCoder.addCodeLine("HSTORE TEMP "+ Integer.toString(tempIndex-1) + " " + Integer.toString(4*i) + " " + currClass.name + "_" + tmp);
            i++;
        }
        //build object
        subCoder.addCodeLine("HSTORE TEMP "+ tempIndex +" 0 TEMP "+ Integer.toString(tempIndex-1) );
        Iterator<String> stringIterator = currClass.initHash.keySet().iterator();
        i=1;
        while (stringIterator.hasNext()){
            String tmp = stringIterator.next();
            subCoder.addCodeLine("HSTORE TEMP "+ tempIndex + " " + Integer.toString(4*i) + " " + tempVarMapping.get(tmp));
            i++;
        }
        //return object
        subCoder.addCodeLine("RETURN TEMP "+ tempIndex);
        indent--;
        subCoder.indent--;
        subCoder.addCodeLine("END");

        tempIndex++;

//        System.out.println("Constructor for "+currClass.name);
//        System.out.println(subCoder.code);
        if(currClass.isFuncCoded == false && currClass.classFuncCodes != null){
           currClass.classFuncCodes.clear();
            currClass.isFuncCoded = true;
        }
        String funcName = "new_"+currClass.name;
        FuncCode constructor = new FuncCode(funcName, subCoder.code);

        currClass.classFuncCodes.add(constructor);
//        System.out.println(currClass.classFuncCodes);
        FuncCode blah = currClass.classFuncCodes.get(currClass.classFuncCodes.indexOf(constructor));
//        System.out.println("Constructor for "+currClass.name);
//        System.out.println(blah.funcCode);

        currClass.classFuncCodes = currFuncCodes;

        currCoder = prevCoder;
        currClass = prevClass;

        return _ret;
    }

    /**
     * f0 -> "class"
     * f1 -> Identifier()
     * f2 -> "extends"
     * f3 -> Identifier()
     * f4 -> "{"
     * f5 -> ( VarDeclaration() )*
     * f6 -> ( MethodDeclaration() )*
     * f7 -> "}"
     */

    //TODO: SHIFT THIS TO FIRST PASS
    public R visit(ClassExtendsDeclaration n) {
        R _ret=null;
        CodeGenerator subCoder = new CodeGenerator();

        ClassDetails prevClass = currClass;
        currClass = symbolTable.get(n.f1.f0.toString());
//        subCoder.addCodeLine(n.f1.f0.toString());
//        subCoder.addCodeLine(n.f3.f0.toString());
//        subCoder.addCodeLine(currClass.name);

//        System.out.println("######################ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆ*****************");
//        System.out.println(currClass.name);
//        System.out.println(currClass.classVars);
//        System.out.println(currVarTable);

        currClass.classFuncCodes = new ArrayList<FuncCode>();
        prevCoder = currCoder;
//        System.out.println(currClass.name);
//        subCoder.addCodeLine("FFFFFFFFFF");
        n.f0.accept(this);
        n.f1.accept(this);
//        subCoder.addCodeLine(currClass.name);

        n.f2.accept(this);
        n.f3.accept(this);
//        subCoder.addCodeLine(currClass.name);

        n.f4.accept(this);
        n.f5.accept(this);
//        subCoder.addCodeLine(currClass.name);

        n.f6.accept(this);
//        subCoder.addCodeLine(currClass.name);

        n.f7.accept(this);

//        subCoder.addCodeLine(currClass.name);

        currClass.initHash = currClass.classVars;
//        subCoder.addCodeLine(">>>>>>>>>>>>>>>>>>>>inClassExtends Decln>>>>>>>>>>>>>>>>>>>>>>");
//        subCoder.addCodeLine("############################");
//        subCoder.addCodeLine(currVarTable.toString());
//        if(currVarTable  != null)
//        subCoder.addCodeLine(currVarTable.toString());
//        subCoder.addCodeLine(currClass.classVars.toString());
        subCoder.addCodeLine("new_"+currClass.name + " [ 0 ]");
        subCoder.addCodeLine("BEGIN");
        indent++;
        subCoder.indent++;
        int vTableSize = 4 * currClass.classFuncs.size();
        int objSize = 4 * (currClass.classVars.size() + 1);
        // allocate vtable
        subCoder.addCodeLine("MOVE TEMP "+ tempIndex +" HALLOCATE "+ vTableSize);
        tempIndex++;
        //allocate object
        subCoder.addCodeLine("MOVE TEMP "+ tempIndex +" HALLOCATE "+ objSize );
        //add to temVarMap
        tempVarMapping.put(currClass.name + "_vTable", tempIndex-1);
        tempVarMapping.put(currClass.name + "_obj_"+currClass.objCount, tempIndex);
        currClass.objCount++;
        //build vtable
        Iterator<String> iterator = currClass.classFuncs.keySet().iterator();
        int i=0;
        while (iterator.hasNext()){
            String tmp = iterator.next();
            subCoder.addCodeLine("HSTORE TEMP "+ Integer.toString(tempIndex-1) + " " + Integer.toString(4*i) + " " + currClass.name + "_" + tmp);
            i++;
        }
        //build object
        subCoder.addCodeLine("HSTORE TEMP "+ tempIndex +" 0 TEMP "+ Integer.toString(tempIndex-1) );
        Iterator<String> stringIterator = currClass.classVars.keySet().iterator();
        i=1;
        while (stringIterator.hasNext()){
            String tmp = stringIterator.next();
            subCoder.addCodeLine("HSTORE TEMP "+ tempIndex + " "+Integer.toString(4*i) +" "+ tempVarMapping.get(tmp));
            i++;
        }
        //return object
        subCoder.addCodeLine("RETURN TEMP "+ tempIndex);
        indent--;
        subCoder.indent--;
        subCoder.addCodeLine("END");

        tempIndex++;

//        System.out.println("Constructor for "+currClass.name);
//        System.out.println(subCoder.code);

        if(currClass.isFuncCoded == false && currClass.classFuncCodes != null){
            currClass.classFuncCodes.clear();
            currClass.isFuncCoded = true;
        }

        String funcName = "new_"+currClass.name;
        FuncCode constructor = new FuncCode(funcName, subCoder.code );

        currClass.classFuncCodes.add(constructor);

        FuncCode blah = currClass.classFuncCodes.get(currClass.classFuncCodes.indexOf(constructor));
//        System.out.println("Constructor for "+currClass.name);
//        System.out.println(blah.funcCode);
        currCoder = prevCoder;
        currClass = prevClass;

        return _ret;
    }

    /**
     * f0 -> Type()
     * f1 -> Identifier()
     * f2 -> ";"
     */

    //TODO: FIRST PASS
    public R visit(VarDeclaration n) {
//        System.out.println(n.f1.f0.toString());
        VarDetails myVar = null;
//        System.out.println(":::::");
//        System.out.println(currClass.name);
        if(inFunc == false){
            myVar = currClass.classVars.get(n.f1.f0.toString());
//            System.out.println("in here..."+myVar.name+" "+myVar);
            currClass.classVars.put(myVar.name, myVar);
        }
        else{
            myVar = currFunc.localVars.get(n.f1.f0.toString());
//            System.out.println(currFunc.name+" Local vars:");
//            System.out.println(currFunc.localVars);
//            System.out.println(currFunc.localVars);
//            System.out.println(n.f1.f0.toString());
//            System.out.println("there..."+myVar);
        }
//        System.out.println("MMMMMMMMMMMMMMMMMMMM");
//        System.out.println(myVar);
        tempVarMapping.put(myVar.name, tempIndex);
        if(inClass || n.f0.f0.which == 0 || n.f0.f0.which == 3){
            heapStore.add(tempIndex);
        }
//        System.out.println("here, "+myVar.name + " : " + tempVarMapping.get(myVar.name));
        tempIndex++;
        R _ret=null;

        Stmt type = (Stmt) n.f0.accept(this);
        if(type != null){
            objRecords.put(myVar.name, symbolTable.get(type.info));
        }
        n.f1.accept(this);
        n.f2.accept(this);
        tempIndex++;
        return _ret;
    }

    /**
     * f0 -> "public"
     * f1 -> Type()
     * f2 -> Identifier()
     * f3 -> "("
     * f4 -> ( FormalParameterList() )?
     * f5 -> ")"
     * f6 -> "{"
     * f7 -> ( VarDeclaration() )*
     * f8 -> ( Statement() )*
     * f9 -> "return"
     * f10 -> Expression()
     * f11 -> ";"
     * f12 -> "}"
     */

    //TODO: First Pass
    public R visit(MethodDeclaration n) {
        R _ret=null;

        CodeGenerator prevCoder = currCoder;
        CodeGenerator myCoder = new CodeGenerator(indent);
//        myCoder.addCodeLine("*************");
//        System.out.println("===========================================");
        FuncDetails myFunc = currClass.classFuncs.get(n.f2.f0.toString());
        currFunc = myFunc;
        inFunc = true;

//        currCoder = myCoder;
        int size;
        if(myFunc.argumentTypes==null)
            size = 1;
        else
            size = myFunc.argumentTypes.size()+1;
//        myCoder.addCodeLine(">>>>>>>>>>>>>>>>>>>>>>>>>>>in MEthod Decln>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
        myCoder.addCodeLine(currClass.name+"_"+myFunc.name+"["+Integer.toString(size)+"]");
        myCoder.addCodeLine("BEGIN");

        indent++;
        myCoder.indent++;

        n.f0.accept(this);
        n.f1.accept(this);
        Stmt funcName = (Stmt) n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
        n.f5.accept(this);
        n.f6.accept(this);

        n.f7.accept(this);
//        myCoder.addCodeLine("••••••••••••••••••••");
        currCoder = myCoder;
        currCoder.code = myCoder.code;
//        System.out.println("currCoder.code b4 stmts: "+currCoder.code);
        n.f8.accept(this);

        myCoder.code = currCoder.code;
//        System.out.println("currCoder.code after stmts: "+myCoder.code);

//        myCoder.addCodeLine("===========");
//        System.out.println(currCoder.code);
        currCoder = prevCoder;

        n.f9.accept(this);


        inFunc = false;
        Stmt expr = (Stmt)n.f10.accept(this);
        if(expr != null){
            if(!Character.isDigit(expr.code.charAt(0))){
                myCoder.addCodeLine(expr.code);
                myCoder.addCodeLine("RETURN TEMP "+expr.retVal);
            }
        }
        myCoder.indent--;
        indent--;
        myCoder.addCodeLine("END");
//        System.out.println("END");
//        currCoder = null;
        n.f11.accept(this);
        n.f12.accept(this);
        FuncCode myFuncCode = new FuncCode(currClass.name+"_"+myFunc.name, myCoder.code );
//        myFuncCode.funcCode = myCoder.code;
//        myFuncCode.funcName = currClass.name+"_"+myFunc.name;
        if(currClass.isFuncCoded == false && currClass.classFuncCodes != null){
            currClass.classFuncCodes.clear();
            currClass.isFuncCoded = true;
        }

        if(currClass.classFuncCodes==null){
            currClass.classFuncCodes = new ArrayList<FuncCode>();
        }
        currClass.classFuncCodes.add(myFuncCode);
        int index = currClass.classFuncCodes.indexOf(myFuncCode);
//        System.out.println("Function "+myFunc.name+ "of class "+currClass.name+ " stored in index "+ index);
//        System.out.println("Function code for "+currClass.name+"."+currFunc.name+"() :");
//        System.out.println(myFuncCode.funcCode);
//        System.out.println("================");
//        System.out.println(myFuncCode.funcCode);
//        String str = "ppppppppppppppppppp";

//        System.out.println(str);
        return _ret;
    }

    /**
     * f0 -> FormalParameter()
     * f1 -> ( FormalParameterRest() )*
     */
    public R visit(FormalParameterList n) {
        paramCount = 1;
        R _ret=null;
        n.f0.accept(this);
        n.f1.accept(this);
        return _ret;
    }

    /**
     * f0 -> Type()
     * f1 -> Identifier()
     */
    public R visit(FormalParameter n) {
        R _ret=null;
        currLocalTemps.put(n.f1.f0.toString(), paramCount);
        paramCount++;
        n.f0.accept(this);
        n.f1.accept(this);
        return _ret;
    }

    /**
     * f0 -> ","
     * f1 -> FormalParameter()
     */
    public R visit(FormalParameterRest n) {
        R _ret=null;
        n.f0.accept(this);
        n.f1.accept(this);
        return _ret;
    }

    /**
     * f0 -> ArrayType()
     *       | BooleanType()
     *       | IntegerType()
     *       | Identifier()
     */
    public R visit(Type n) {
        R _ret=null;
        n.f0.accept(this);
        return _ret;
    }

    /**
     * f0 -> "int"
     * f1 -> "["
     * f2 -> "]"
     */
    public R visit(ArrayType n) {
        R _ret=null;
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        return _ret;
    }

    /**
     * f0 -> "boolean"
     */
    public R visit(BooleanType n) {
        R _ret=null;
        n.f0.accept(this);
        if(inFunc){

        }
        return _ret;
    }

    /**
     * f0 -> "int"
     */
    public R visit(IntegerType n) {
        R _ret=null;
        n.f0.accept(this);
        return _ret;
    }

    /**
     * f0 -> Block()
     *       | AssignmentStatement()
     *       | ArrayAssignmentStatement()
     *       | IfStatement()
     *       | WhileStatement()
     *       | PrintStatement()
     */

    //TODO: 2nd pass
    public R visit(Statement n) {
//        System.out.println("||||||||bbbbb|||||||"+currCoder.toString());
        Stmt myStmt = new Stmt();
        R _ret=null;
        Stmt prevStmt = currStmt;
        currStmt = myStmt;
        myStmt.nextLabel = labelIndex;
        labelIndex++;
        myStmt = (Stmt) n.f0.accept(this);
//        System.out.println("|||||||aaaaa||||||||"+currCoder.toString()+currCoder.code+": "+n.f0.which);
         currStmt = prevStmt;

//        labelIndex++;
        if(myStmt!=null){
            if(!inIf)
                currCoder.addCodeLine(myStmt.code);
        }
//        System.out.println("|||||||||||||||||||"+currCoder.code);
        return (R) myStmt;
    }

    /**
     * f0 -> "{"
     * f1 -> ( Statement() )*
     * f2 -> "}"
     */
    //TODO: Second Pass
    public R visit(Block n) {
        R _ret=null;
        Stmt myBlock = new Stmt();
        CodeGenerator myCoder = new CodeGenerator(indent);
        CodeGenerator prevCoder = currCoder;
//        myCoder.addCodeLine("BEGIN");
        myBlock.nextLabel = currStmt.nextLabel;
        myCoder.indent++;
        indent++;
        currCoder = myCoder;
        Stmt prevStmt = currStmt;
        currStmt = myBlock;
        n.f0.accept(this);
        n.f1.accept(this);
        System.out.println(myBlock.code);
        n.f2.accept(this);
        currStmt = prevStmt;

        currStmt = prevStmt;
        currCoder = prevCoder;
        indent--;
        myCoder.indent--;
//        myCoder.addCodeLine("END");
        myBlock.code=myCoder.code;
        myBlock.retVal=0;
        return (R) myBlock;
    }

    /**
     * f0 -> Identifier()
     * f1 -> "="
     * f2 -> Expression()
     * f3 -> ";"
     */
    //TODO: Second Pass

    public R visit(AssignmentStatement n) {
        R _ret=null;
//        System.out.println(":::::::"+currCoder.toString());

        Stmt myAssign = new Stmt();
        CodeGenerator myCoder = new CodeGenerator(indent);
        isAssign = true;
        Integer varIndex = currLocalTemps.get(n.f0.f0.toString());
        if(varIndex==null)
            varIndex = tempVarMapping.get(n.f0.f0.toString());
        String tmp = "TEMP "+Integer.toString(varIndex);
        Stmt prevStmt = currStmt;
        n.f0.accept(this);
//        System.out.println("maami.....");
        n.f1.accept(this);
//        System.out.println(currCoder.toString());

        Stmt expr = (Stmt)n.f2.accept(this);
//        System.out.println(":::::::"+currCoder.toString() + n.f2.f0.which);

        myCoder.addCodeLine(expr.code);
        if(expr.isClassAlloc){
            myCoder.addCodeLine("MOVE TEMP "+tempIndex+" 0 TEMP "+expr.retVal);
            tempIndex++;
        }
        if(heapStore.contains(expr.retVal)){
            myCoder.addCodeLine("HSTORE "+tmp+" 0 TEMP "+expr.retVal);
        }
        else{
            myCoder.addCodeLine("MOVE "+tmp+" TEMP "+expr.retVal);
        }
        int i = tempVarMapping.get(n.f0.f0.toString());
//        tempVarMapping.put(n.f0.f0.toString(),expr.retVal);
        if(heapStore.contains(i))
            heapStore.add(expr.retVal);
        currStmt = prevStmt;

        n.f3.accept(this);
        myAssign.code = myCoder.code;
//        System.out.println("ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ");
//        System.out.println("myCoder.code =  "+ myCoder.code);
//        System.out.println("myAssign.code = "+myAssign.code);
        isAssign=false;
//        System.out.println(":::::::"+currCoder.toString());

        return (R) myAssign;
    }

    /**
     * f0 -> Identifier()
     * f1 -> "["
     * f2 -> Expression()
     * f3 -> "]"
     * f4 -> "="
     * f5 -> Expression()
     * f6 -> ";"
     */
    //TODO: Second Pass

    public R visit(ArrayAssignmentStatement n) {
        R _ret=null;
        Stmt myArrAssign = new Stmt();
        CodeGenerator myCoder = new CodeGenerator(indent);
        Integer varIndex = currLocalTemps.get(n.f0.f0.toString());
        if(varIndex==null)
            varIndex = tempVarMapping.get(n.f0.f0.toString());
        String tmp = "TEMP "+Integer.toString(varIndex);
//        myCoder.addCodeLine("MOVE "+tmp+" ");
        Stmt prevStmt = currStmt;
        Stmt id = (Stmt) n.f0.accept(this);
        n.f1.accept(this);
        Stmt index = (Stmt) n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
//        myCoder.addCode(" ");
        Stmt val = (Stmt) n.f5.accept(this);
        n.f6.accept(this);
        int array_base = tempVarMapping.get(id.info);
        myCoder.addCodeLine(val.code);
        myCoder.addCodeLine(index.code);

        myCoder.addCodeLine("HSTORE PLUS TEMP "+array_base+" TEMP "+index.retVal+" 0 TEMP "+val.retVal);

        myArrAssign.code = myCoder.code;
        currStmt = prevStmt;
        return (R) myArrAssign;
    }

    /**
     * f0 -> "if"
     * f1 -> "("
     * f2 -> Expression()
     * f3 -> ")"
     * f4 -> Statement()
     * f5 -> "else"
     * f6 -> Statement()
     */
    //TODO: Second Pass

    public R visit(IfStatement n) {
        R _ret=null;
        Stmt myIf = new Stmt();
        myIf.nextLabel = labelIndex;
        labelIndex++;
        n.f0.accept(this);
        n.f1.accept(this);
        inIf = true;
        Stmt expr = (Stmt) n.f2.accept(this);
        if(expr != null){
            expr.ifTrueLabel = labelIndex;
            labelIndex++;
            expr.ifFalseLabel = labelIndex;
            labelIndex++;
        }
        n.f3.accept(this);
        Stmt s1 = (Stmt)n.f4.accept(this);
        n.f5.accept(this);
        Stmt s2 = (Stmt)n.f6.accept(this);
//        s1.next=s2.next=myIf.next;

        CodeGenerator myGen = new CodeGenerator(indent);
//        System.out.println("hello, "+expr);
        try{
//            myGen.addCodeLine("--1--");
            myGen.addCodeLine(expr.code);
            myGen.addCodeLine("CJUMP LT 0 TEMP "+expr.retVal+" L"+expr.ifFalseLabel);
            myGen.addLabel("L" + expr.ifTrueLabel);
        }
        catch (Exception e){
            myGen.addCodeLine("<expression's code>");
            myGen.addCodeLine("CJUMP LT 0 <expr's retVal> L"+expr.ifFalseLabel);
            myGen.addLabel("<expr's True label>");

        }
        try{
//            myGen.addCodeLine("--2--");
            myGen.addCodeLine(s1.code);
        }
        catch (Exception e){
            myGen.addCodeLine("<True stmt>");
        }
        myGen.addCodeLine("JUMP L" + myIf.nextLabel);
        try{
//            myGen.addCodeLine("--3--");
            myGen.addLabel("L" + expr.ifFalseLabel);
        }
        catch (Exception e){
            myGen.addLabel("<expr's false label>");
        }
        try{
//            myGen.addCodeLine("--4--");
            myGen.addCodeLine(s2.code);
        }
        catch (Exception e){
            myGen.addCodeLine("<False Stmt>");
        }
        myGen.addLabel("L"+myIf.nextLabel);
        inIf= false;
        myIf.code = myGen.code;

//        System.out.println("If seen....");
//        System.out.println(myIf.code);

        return (R) myIf;
    }

    /**
     * f0 -> "while"
     * f1 -> "("
     * f2 -> Expression()
     * f3 -> ")"
     * f4 -> Statement()
     */
    //TODO: Second Pass

    public R visit(WhileStatement n) {
        R _ret=null;
        Stmt myWhile = new Stmt();
        n.f0.accept(this);
        n.f1.accept(this);
        int begin = labelIndex;
        labelIndex++;
        myWhile.nextLabel = labelIndex;
        labelIndex++;
        Stmt expr = (Stmt) n.f2.accept(this);
        n.f3.accept(this);
        Stmt s = (Stmt) n.f4.accept(this);
        CodeGenerator myCoder = new CodeGenerator(indent);

        myCoder.addLabel("L"+labelIndex);
        try{
            myCoder.addCodeLine(expr.code);
            myCoder.addCodeLine("CJUMP LT 0 TEMP "+expr.retVal+" L"+myWhile.nextLabel);
        }
        catch (Exception e){
            myCoder.addCodeLine("<expr.code>");
            myCoder.addCodeLine("CJUMP LT 0 TEMP "+"<expr.retVal>"+"<myWhile.nextLabel>" );

        }
        try{
            myCoder.addCodeLine(s.code);
        }
        catch (Exception e){
            myCoder.addCodeLine("<loop body>");
        }
        myCoder.addCodeLine("JUMP L"+labelIndex);
        myCoder.addLabel("L"+myWhile.nextLabel);

        System.out.println(myWhile.code);

        myWhile.code = myCoder.code;

//        System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
//        System.out.println(myWhile.code);
//        System.out.println("+++++++++++++++++++++++++++++++++++");

        return (R) myWhile;
    }

    /**
     * f0 -> "System.out.println"
     * f1 -> "("
     * f2 -> Expression()
     * f3 -> ")"
     * f4 -> ";"
     */
    //TODO: Second Pass

    public R visit(PrintStatement n) {
        R _ret=null;
        Stmt myPrint = new Stmt();
        n.f0.accept(this);
        n.f1.accept(this);
        Stmt expr = (Stmt) n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
        CodeGenerator myCoder = new CodeGenerator(indent);
//        System.out.println("¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬");
//        System.out.println(expr.code);
        if(expr.code!=null)
            myCoder.addCodeLine(expr.code);
        myCoder.addCodeLine("PRINT TEMP ");
        myCoder.addCode(Integer.toString(expr.retVal));
        myPrint.code = myCoder.code;
//        System.out.println("[[[[[[[[[[[[[[[[[[[");
//        System.out.println(expr.code);
//        System.out.println(n.f2.f0.which);
        return (R) myPrint;
    }

    /**
     * f0 -> AndExpression()                0
     *       | CompareExpression()          1
     *       | PlusExpression()             2
     *       | MinusExpression()            3
     *       | TimesExpression()            4
     *       | ArrayLookup()                5
     *       | ArrayLength()                6
     *       | MessageSend()                7
     *       | PrimaryExpression()          8
     */
    //TODO: Second Pass

    public R visit(Expression n) {
        R _ret=null;
        inExpr = true;
//        System.out.println("≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈");
//        System.out.println(currClass.name);
        Stmt myExpr = (Stmt) n.f0.accept(this);
//        System.out.println(currClass.name);
//        System.out.println(n.f0.which);
//        System.out.println("ççççççççççççççççççççççççççççççççç");
//        System.out.println("ExprChoice: "+n.f0.which);
        inExpr = false;

        return (R) myExpr;
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "&"
     * f2 -> PrimaryExpression()
     */           //TODO: Second Pass

    public R visit(AndExpression n) {
        R _ret=null;
        Stmt myAnd = currStmt;
//        Stmt b1 = new Stmt();
//        Stmt b2 = new Stmt();
        //b1.ifTrue = newLabel();
//        b1.ifFalse = myAnd.ifFalse;
//        b2.ifTrue = myAnd.ifTrue;
//        b2.ifFalse = myAnd.ifFalse;
        Stmt pe1 = (Stmt) n.f0.accept(this);
//        b1.code = pe1.code;
        n.f1.accept(this);
        Stmt pe2 = (Stmt) n.f2.accept(this);
//        b2.code = pe2.code;
        String label = "L"+ Integer.toString(labelIndex);
        labelIndex++;
        CodeGenerator newGen = new CodeGenerator(indent);
        newGen.addCodeLine(pe1.code);
        newGen.addCodeLine("CJUMP LT TEMP "+pe1.retVal+" 1 L"+labelIndex);
        int falseLabel = labelIndex;
        labelIndex++;
        newGen.addCodeLine(pe2.code);
        newGen.addCodeLine("MOVE TEMP "+tempIndex+" 1");
        newGen.addCodeLine("JUMP L"+labelIndex);
        newGen.addLabel("L" + falseLabel);
        newGen.addCodeLine("MOVE TEMP " + tempIndex + " 0");
        newGen.addLabel("L" + labelIndex);
        labelIndex++;
        tempIndex++;

        myAnd.code = newGen.code;
//        System.out.println("And Code : "+ myAnd.code);
        return (R) myAnd;
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "<"
     * f2 -> PrimaryExpression()
     */
    //TODO: Second Pass

    public R visit(CompareExpression n) {
        R _ret=null;
//        System.out.println("Compare Stmt...");
        Stmt myComp = new Stmt();
        Stmt pe1 = (Stmt) n.f0.accept(this);
        n.f1.accept(this);
        Stmt pe2 = (Stmt) n.f2.accept(this);
        CodeGenerator newGen = new CodeGenerator(indent);
        newGen.addCodeLine(pe1.code);
        newGen.addCodeLine(pe2.code);
        int falseStmt = labelIndex;
        labelIndex++;
        int outStmt = labelIndex;
        labelIndex++;
        newGen.addCodeLine("CJUMP LT TEMP "+pe1.retVal+" TEMP "+pe2.retVal+ " L"+falseStmt);
        newGen.addCodeLine("MOVE TEMP "+tempIndex+" 1");
        newGen.addCodeLine("JUMP L"+outStmt);
        newGen.addLabel("L" + falseStmt);
        newGen.addCodeLine("MOVE TEMP " + tempIndex + " 0");
        newGen.addLabel("L"+outStmt);
        tempIndex++;
        myComp.retVal = tempIndex - 1;
        myComp.code = newGen.code;
        return (R) myComp;
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "+"
     * f2 -> PrimaryExpression()
     */
    //TODO: Second Pass

    public R visit(PlusExpression n) {
        R _ret=null;
        Stmt myPlus = new Stmt();
        CodeGenerator myCoder = new CodeGenerator(indent);
        Stmt prevStmt = currStmt;
        currStmt = myPlus;
        Stmt pe1 = (Stmt)n.f0.accept(this);
        n.f1.accept(this);
        Stmt pe2 = (Stmt)n.f2.accept(this);
        if(pe1 != null && pe2 != null){
            myCoder.addCodeLine(pe1.code);
            myCoder.addCodeLine(pe2.code);
            myCoder.addCodeLine("MOVE TEMP "+tempIndex+" PLUS TEMP "+pe1.retVal+" TEMP "+pe2.retVal);
        }
        myPlus.retVal = tempIndex;
        tempIndex++;
        currStmt = prevStmt;
        myPlus.code = myCoder.code;
        return (R) myPlus;
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "-"
     * f2 -> PrimaryExpression()
     */
    //TODO: Second Pass

    public R visit(MinusExpression n) {
        R _ret=null;
        Stmt myMinus = new Stmt();
        CodeGenerator myCoder = new CodeGenerator(indent);
//        currCoder = myCoder;
        Stmt prevStmt = currStmt;
        currStmt=myMinus;
        Stmt pe1 = (Stmt)n.f0.accept(this);
        n.f1.accept(this);
        Stmt pe2 = (Stmt)n.f2.accept(this);
        if(pe1 != null && pe2 != null){
            myCoder.addCodeLine(pe1.code);
            myCoder.addCodeLine(pe2.code);
            myCoder.addCodeLine("MOVE TEMP "+tempIndex+" MINUS TEMP "+pe1.retVal+" TEMP "+pe2.retVal);
            tempIndex++;
        }
        myMinus.retVal = tempIndex-1;
        currStmt = prevStmt;
        myMinus.code = myCoder.code;
        return (R) myMinus;
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "*"
     * f2 -> PrimaryExpression()
     */
    //TODO: Second Pass

    public R visit(TimesExpression n) {
        R _ret=null;
        Stmt myTimes = new Stmt();
        CodeGenerator myCoder  =new CodeGenerator(indent);
        Stmt prevStmt = currStmt;
        currStmt = myTimes;
        Stmt pe1 = (Stmt) n.f0.accept(this);
        n.f1.accept(this);
        Stmt pe2 = (Stmt)n.f2.accept(this);
//        System.out.println("pe1 : "+n.f0.f0.which);
//        System.out.println("pe2 : "+n.f2.f0.which);
        if(pe1 != null)
            myCoder.addCodeLine(pe1.code);
        if(pe2 != null)
            myCoder.addCodeLine(pe2.code);
        myCoder.addCodeLine("MOVE TEMP " + tempIndex + " TIMES TEMP "+pe1.retVal+" TEMP "+pe2.retVal);
        currStmt = prevStmt;
        myTimes.retVal = tempIndex;
        tempIndex++;
        myTimes.code = myCoder.code;
        return (R) myTimes;
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "["
     * f2 -> PrimaryExpression()
     * f3 -> "]"
     */      //TODO: Second Pass

    public R visit(ArrayLookup n) {
        R _ret=null;
        Stmt myArrLookup = new Stmt();


        Stmt pe1 = (Stmt) n.f0.accept(this);
        n.f1.accept(this);
        Stmt pe2 = (Stmt) n.f2.accept(this);

        CodeGenerator myCoder = new CodeGenerator(indent);
        int array_index = tempVarMapping.get(pe1.info);

        myCoder.addCodeLine("HLOAD TEMP "+tempIndex+" TEMP "+array_index+" TEMP "+pe2.retVal );
        n.f3.accept(this);
        myArrLookup.code = myCoder.code;
        myArrLookup.retVal = tempIndex;
        tempIndex++;
        return (R) myArrLookup;
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "."
     * f2 -> "length"
     */
    //TODO: Second Pass

    public R visit(ArrayLength n) {
        R _ret=null;
//        System.out.println(n.f0.f0.choice);
        Stmt pe = null;
        Integer i =null;
        if(n.f0.f0.which!=3){
//            System.out.println("Not an Id");
            pe = (Stmt) n.f0.accept(this);
        }
        else{
//            System.out.println("Id...");
            try{
                i = (Integer) n.f0.accept(this);
            }
            catch (Exception e){}
            if(i!=null){
                pe = new Stmt();
                pe.retVal = i;
                pe.code = Integer.toString(i);
            }
            else{
                pe = (Stmt) n.f0.accept(this);
//                System.out.println(pe.code);
                pe.retVal = Integer.parseInt(pe.code);
                pe.code="";


            }

        }
        n.f1.accept(this);
        n.f2.accept(this);
        Stmt myArrLen = new Stmt();

        CodeGenerator myCoder = new CodeGenerator(indent);
        myCoder.addCodeLine(pe.code);
        myCoder.addCodeLine("BEGIN");
        myCoder.indent++;
        indent++;
        myCoder.addCodeLine("aaa TEMP "+tempIndex+" "+pe.retVal+" 0");
        int oldTmp1 = tempIndex;
        tempIndex++;
        myCoder.addCodeLine("MOVE TEMP "+tempIndex+" 4");
        int oldTmp2 = tempIndex;
        tempIndex++;
        myCoder.addCodeLine("MOVE TEMP "+tempIndex+" 0");
        int oldTmp3 = tempIndex;
        tempIndex++;
        myCoder.addCodeLine("MOVE TEMP "+tempIndex+" 0");
        myCoder.addLabel("L"+labelIndex);
        int loopLabel = labelIndex;
        labelIndex++;
        myCoder.addCodeLine("CJUMP LT TEMP "+oldTmp2+" TEMP "+oldTmp1+" L"+labelIndex);
        myCoder.addCodeLine("MOVE TEMP "+oldTmp2+" PLUS TEMP "+oldTmp2+" 4");
        myCoder.addCodeLine("MOVE TEMP "+oldTmp3+" PLUS TEMP "+oldTmp3+" 1");
        myCoder.addCodeLine("JUMP L"+loopLabel);
        myCoder.addLabel("L"+labelIndex);
        myCoder.addCodeLine("RETURN TEMP "+oldTmp3);
        indent--;
        myCoder.indent--;
        myCoder.addCodeLine("END");
        labelIndex++;
//        myCoder.addCodeLine("");
        myArrLen.code = myCoder.code;
        myArrLen.retVal = oldTmp3;

//        System.out.println("Code for Array.length: ");
//        System.out.println(myArrLen.code);
        return (R) myArrLen;
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "."
     * f2 -> Identifier()
     * f3 -> "("
     * f4 -> ( ExpressionList() )?
     * f5 -> ")"
     */
    //TODO: Second Pass

    public R visit(MessageSend n) {
        Stmt myMsgSend = new Stmt();
        CodeGenerator myCoder = new CodeGenerator(indent);
        ArrayList<Integer> params = new ArrayList<Integer>();
        currParams = params;
        CodeGenerator prevCoder  = currCoder;
        currCoder = myCoder;
        Stmt pe = (Stmt) n.f0.accept(this);
        n.f1.accept(this);
        Stmt id = (Stmt) n.f2.accept(this);
        n.f3.accept(this);
        Stmt exprList = (Stmt) n.f4.accept(this);
        n.f5.accept(this);
        String func_name;
        if(pe.info != "this" && pe.isClassAlloc == false){
            ClassDetails myCLass = objRecords.get(pe.info);
            FuncDetails myFunc = myCLass.classFuncs.get(id.info);
            func_name = myCLass.name+"_"+myFunc.name;
            params.add(tempVarMapping.get(pe.info));
        }
        else if(pe.isClassAlloc == false){
            FuncDetails myFunc = currClass.classFuncs.get(id.info);
            func_name = currClass.name+"_"+myFunc.name;
            params.add(0,0);
        }
        else{
            ClassDetails myClass = symbolTable.get(pe.info);
            FuncDetails my_func = myClass.classFuncs.get(id.info);
            func_name = myClass.name+"_"+my_func.name;

        }
        String funcParams= "";
        Iterator<Integer> myIter = params.iterator();
        while (myIter.hasNext()){
            int i = myIter.next();
            funcParams = funcParams+"TEMP "+i+" ";
        }
        if(pe.isClassAlloc) {
            myCoder.addCodeLine(pe.code);
            myCoder.addCodeLine("MOVE TEMP "+tempIndex+" CALL "+func_name+"( TEMP "+pe.retVal+" "+funcParams+")");
        }
        else{
            myCoder.addCodeLine("MOVE TEMP "+tempIndex+" CALL "+func_name+"( "+funcParams+")");
        }

        myMsgSend.code = myCoder.code;
        myMsgSend.retVal = tempIndex;
        tempIndex++;
        currCoder = prevCoder;

        return (R) myMsgSend;
    }

    /**
     * f0 -> Expression()
     * f1 -> ( ExpressionRest() )*
     */      //TODO: Second Pass

    public R visit(ExpressionList n) {
        R _ret=null;
        Stmt expr = (Stmt) n.f0.accept(this);
        currCoder.addCodeLine(expr.code);
        currParams.add(expr.retVal);
        n.f1.accept(this);

        return _ret;
    }

    /**
     * f0 -> ","
     * f1 -> Expression()
     */
    //TODO: Second Pass

    public R visit(ExpressionRest n) {
        R _ret=null;

        n.f0.accept(this);
        Stmt expr = (Stmt) n.f1.accept(this);
        currCoder.addCodeLine(expr.code);
        currParams.add(expr.retVal);
        return _ret;
    }

    /**
     * f0 -> IntegerLiteral()               0
     *       | TrueLiteral()                1
     *       | FalseLiteral()               2
     *       | Identifier()                 3
     *       | ThisExpression()             4
     *       | ArrayAllocationExpression()  5
     *       | AllocationExpression()       6
     *       | NotExpression()              7
     *       | BracketExpression()          8
     */

    //TODO: Pass

    public R visit(PrimaryExpression n) {
        R _ret=null;
        Integer i = null;
        Stmt myPE;
        try{
            i = (Integer) n.f0.accept(this);
        }
        catch (Exception e){};
        if(n.f0.which == 3 && i!= null){
            myPE = new Stmt();
            myPE.code=Integer.toString(i);
            myPE.retVal=i;
            return (R) myPE;
        }
//        if(n.f0.which == 0 || n.f0.which == 3)
//            System.out.println("PE : "+ myPE.code);
        else{
            myPE = (Stmt)n.f0.accept(this);
            return (R) myPE;
        }
    }

    /**
     * f0 -> <INTEGER_LITERAL>
     */
    public R visit(IntegerLiteral n) {
        R _ret=null;
        n.f0.accept(this);
        Stmt myInt = new Stmt();
        myInt.code = "MOVE TEMP "+tempIndex+" "+n.f0.toString();
//        System.out.println("myInt = "+ myInt.code);
        myInt.retVal = tempIndex;
        myInt.info = n.f0.toString();
        tempIndex++;
        return (R) myInt;
    }

    /**
     * f0 -> "true"
     */
    public R visit(TrueLiteral n) {
        R _ret=null;
        n.f0.accept(this);
        Stmt myTrue = new Stmt();
        myTrue.code = "1";
        myTrue.retVal=1;
        return (R)myTrue;
    }

    /**
     * f0 -> "false"
     */
    public R visit(FalseLiteral n) {
        R _ret=null;
        n.f0.accept(this);
        Stmt myFalse = new Stmt();
        myFalse.code = "0";
        myFalse.retVal=0;
        return (R)myFalse;
    }

    /**
     * f0 -> <IDENTIFIER>
     */


    public R visit(Identifier n) {
        R _ret=null;
        n.f0.accept(this);

        String varName = n.f0.toString();
        if(tempVarMapping.get(varName) != null){
            int i = tempVarMapping.get(varName);
//            System.out.println(i + " : "+ varName);
//            System.out.println(objRecords);
//            System.out.println(varName);


            if(objRecords.get(varName) != null){
                System.out.println("in here....");
                System.out.println(objRecords);
                ClassDetails myClass  = objRecords.get(varName);
                int index = tempVarMapping.get(varName);
                Stmt myId = new Stmt();
                myId.code = "HLOAD TEMP "+tempIndex+" TEMP "+index+" 0";
                myId.retVal = index;
                tempIndex++;
                myId.info=varName;
            }

            if(inFunc && currClass.classVars.get(varName) != null){
                Stmt myId = new Stmt();
                Iterator<String> it = currClass.classVars.keySet().iterator();
                int offset = 1;
                while(it.hasNext()){
                    String s = it.next();
                    if(currClass.classVars.get(s).name != varName )
                          offset++;
                }
                CodeGenerator myCoder = new CodeGenerator(indent);
                myCoder.addCodeLine("MOVE TEMP "+tempIndex+" TEMP 0");

                int c = tempIndex;
                tempIndex++                                                       ;
                myCoder.addCodeLine("HLOAD TEMP "+i+" PLUS TEMP "+c+" "+ offset+" 0" );
                myId.code = myCoder.code;
                myId.retVal=i;
                myId.info=varName;
            }

            // if it is a heap storage
            if(heapStore.contains(i) ){
                Stmt myId = new Stmt();
                myId.code = "HLOAD TEMP "+tempIndex+" TEMP "+i+" 0";
                myId.retVal = tempIndex;
                tempIndex++;
                myId.info = varName;
                return (R) myId;
            }

            else{
                Stmt myId =new Stmt();
                myId.code ="MOVE TEMP "+tempIndex+" TEMP "+i;
                myId.retVal = tempIndex;
                tempIndex++;
                myId.info  = varName;
                return (R) myId;
            }
        }
        else{
            Stmt myId = new Stmt();
            myId.code = "";
            try{
                myId.retVal = currLocalTemps.get(varName);
//                System.out.println("in here..."+varName);
//                System.out.println(currLocalTemps);
                myId.info = varName;
//                System.out.println("id.retVal = "+myId.retVal);
            }
            catch (Exception e){
                myId.retVal = 0;
                myId.info = varName;
            }
            return (R) myId;
        }


    }

    /**
     * f0 -> "this"
     */
    public R visit(ThisExpression n) {
        R _ret=null;
        n.f0.accept(this);
        Stmt myThis  = new Stmt();
        myThis.info = "this";
//        tempIndex++;
        return (R) myThis;
    }

    /**
     * f0 -> "new"
     * f1 -> "int"
     * f2 -> "["
     * f3 -> Expression()
     * f4 -> "]"
     */
    public R visit(ArrayAllocationExpression n) {
        R _ret=null;
        Stmt myIntArr = new Stmt();
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        Stmt Expr = (Stmt) n.f3.accept(this);
//        int size = Expr.retVal * 4;
        CodeGenerator myCoder = new CodeGenerator(indent);
        myCoder.addCodeLine("MOVE TEMP "+tempIndex+" ");
        int ret = tempIndex;
        tempIndex++;
        myCoder.addCodeLine("BEGIN");
        myCoder.indent++;
        indent++;
        myCoder.addCodeLine("MOVE TEMP "+tempIndex+" HALLOCATE TIMES PLUS TEMP "+Expr.retVal+" 1 4");
        int oldTmp = tempIndex;
        tempIndex++;
        myCoder.addCodeLine("MOVE TEMP "+tempIndex+" 4");
        myCoder.addLabel("L" + labelIndex);
        labelIndex++;
        myCoder.addCodeLine("CJUMP LT TEMP "+tempIndex+" TIMES PLUS "+Expr.retVal+" 1 4 L" + labelIndex);
        myCoder.addCodeLine("HSTORE PLUS TEMP "+oldTmp+" TEMP "+ tempIndex+ " 0 0");
        myCoder.addCodeLine("MOVE TEMP "+ tempIndex+" PLUS TEMP "+ tempIndex+ " 4");
        myCoder.addCodeLine("JUMP L"+Integer.toString(labelIndex-1));
        myCoder.addLabel("L" + labelIndex);
        myCoder.addCodeLine("HSTORE TEMP " + oldTmp + " 0 TIMES 4 TEMP " + Expr.retVal);
        myCoder.addCodeLine("RETURN TEMP "+oldTmp);
        indent--;
        myCoder.indent--;
        myCoder.addCodeLine("END");
        myIntArr.code = myCoder.code;
        myIntArr.retVal = ret;
        tempIndex++;
        n.f4.accept(this);
//        System.out.println("Array allocation: ");
//        System.out.println(myIntArr.code);
        return (R) myIntArr;
    }

    /**
     * f0 -> "new"
     * f1 -> Identifier()
     * f2 -> "("
     * f3 -> ")"
     */
    public R visit(AllocationExpression n) {
        R _ret=null;
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);
        Stmt myClassAlloc = new Stmt();
        ClassDetails prevClass = currClass;
        currClass = symbolTable.get(n.f1.f0.toString());

        CodeGenerator myCoder = new CodeGenerator(indent);
        myCoder.addCodeLine("MOVE TEMP "+tempIndex + " CALL new_"+n.f1.f0.toString()+"()");

        myClassAlloc.code = myCoder.code;
        myClassAlloc.retVal = tempIndex;
        myClassAlloc.info = currClass.name;
        myClassAlloc.isClassAlloc =  true;
        tempIndex++;

        currClass = prevClass;

        return (R) myClassAlloc;
    }

    /**
     * f0 -> "!"
     * f1 -> Expression()
     */
    public R visit(NotExpression n) {
        R _ret=null;
        Stmt myNot = new Stmt();
//        myNot.ifTrueLabel =  currStmt.ifFalseLabel;
//        myNot.ifFalseLabel = currStmt.ifTrueLabel;
        n.f0.accept(this);
        Stmt expr = (Stmt) n.f1.accept(this);
        CodeGenerator myCoder = new CodeGenerator(indent);
        myCoder.addCodeLine(expr.code);
        int _0 = labelIndex;
        labelIndex++;
        int _1 = labelIndex;
        labelIndex++;
        int tmp = labelIndex;
        labelIndex++;
        myCoder.addCodeLine("CJUMP LT TEMP "+expr.retVal+" 1 L"+_1);
        myCoder.addCodeLine("MOVE TEMP "+tmp+" 1");
        myCoder.addCodeLine("JUMP L"+_0);
        myCoder.addLabel("L" + _1);
        myCoder.addCodeLine("MOVE TEMP "+tmp+" 0");
        myCoder.addLabel("L"+_0);

        myNot.code = myCoder.code;
        myNot.retVal = tmp;
        return (R) myNot;
    }

    /**
     * f0 -> "("
     * f1 -> Expression()
     * f2 -> ")"
     */
    public R visit(BracketExpression n) {
        R _ret=null;
        Stmt myBE = new Stmt();

        n.f0.accept(this);
        Stmt e = (Stmt) n.f1.accept(this);
        n.f2.accept(this);
        CodeGenerator myCoder = new CodeGenerator(indent);
        myCoder.addCodeLine(e.code);
        myBE.retVal = e.retVal;
        myBE.code = myCoder.code;

        return (R) myBE;
    }

}
